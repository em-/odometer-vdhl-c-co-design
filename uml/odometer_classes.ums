/*
 * File: odometer_classes.ums
 * Autore: Emanuele Aina <em@nerd.ocracy.org>
 * Licenza: LGPL
 */

class Odometer {
    fields {
        #angle: int;
        #revolutions: int;
        #K: int;
        #K1: int;
        #K2: int;
        #coeff: int;
    }
    operations {
        +setCoeff(value: int): void;
        +setK(value: int): void;
        +setK1(value: int): void;
        +setK2(value: int): void;
        +rotationClockWise(): void;
        +rotationCounterClockWise(): void;
        +revolution(): void;
        +getAngle(): int;
        +getRevolutions(): int;
        +reset(): void;
    }
}

class EncoderInterface {
    operations {
        +A(value: boolean): void;
        +B(value: boolean): void;
        +Z(value: boolean): void;
        +reset(): void;
    }
}

class OutputInterface {
    operations {
        +tick(): void;
        +reset(): void;
    }
}

class SerialController {
    operations {
        +txBusy(value: boolean): void;
        +rxAv(value: boolean): void;
        +getStatus(): byte;
        +getData(): byte;
        +setData(value: byte): void;
        +reset(): void;
    }
}

class SerialInterface {
    operations {
        +serialNotify(): void;
        +reset(): void;
    }
}

class Uart {
    fields {
        #byteRx: byte;
        #byteTx: byte;
        #txBusy: boolean;
        #rxAv:   boolean;
    }
    operations {
        +readRxData(): byte;
        +loadTxData(): byte;
        +reset(): void;
    }
}

classdiagram odometer_classes {
    comment = "Diagrammi delle classi";
    layout = hierarchy;
    entities {
        Odometer depends SerialInterface;
        SerialInterface depends SerialController;
        SerialController depends Uart;
        Odometer depends EncoderInterface;
        Odometer depends OutputInterface;
    }
}

