\documentclass [11pt,a4paper,oneside]{article}

\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{verbatim}
\usepackage{color}
\usepackage{listings}

% Informations
\title{Odometro incrementale}
\author{Emanuele Aina (matr. 129548)}
\date{}

% Margins
\geometry{bindingoffset=0.5cm}

% Caption
\newcommand{\mc}[1]{{\small\ #1}}
\newcommand{\makecaption}[1]{\caption{\mc\ #1}}

% URL
\newcommand{\url}[2]{#1\footnote{#2}}

% References
\newcommand{\refemph}[1]{\emph{#1}}
\newcommand{\imgref}[1]{\refemph{\ref{img:#1}}}
\newcommand{\imgrefx}[1]{\refemph{figura}~\imgref{#1}}

% Images
\newcommand{\im}[3]{
    \begin{figure}[!htb]
        \begin{center}
            \includegraphics{img/#1}
            \makecaption{#2}
            \label{img:#3}
        \end{center}
    \end{figure}
}

% Collegamenti.
\definecolor{links}{rgb}{0.7,0.2,0}
\usepackage{ifpdf}
\ifpdf
    \usepackage{hyperref}
    \hypersetup{colorlinks=true,bookmarks=true,hypertexnames=false,urlcolor=links}
\else
    \newcommand{\href}[2]{#2}
\fi
\newcommand{\link}[1]{\href{#1}{#1}}

% Ignore the argument
\newcommand{\noop}[1]{}

% Foreign words
\newcommand{\foreign}[1]{\emph{#1}}

\newcommand{\component}[1]{\texttt{#1}}
\newcommand{\identifier}[1]{\texttt{#1}}

% Justify even if it has to leave a lot of blank space
\setlength{\emergencystretch}{3em}

\definecolor{comment}{rgb}{0,0,0.8}
\definecolor{keyword}{rgb}{0.9,0.5,0}
\definecolor{string}{rgb}{0.95,0,0}

\lstset{
    basicstyle=\ttfamily,
    % this sets the letter spacing as it is with the verbatim package
    basewidth=0.5em,
    keywordstyle=\color{keyword},
    commentstyle=\color{comment},
    stringstyle=\color{string},
    showstringspaces=false,
}


\begin{document}

\maketitle

\begin{center}
\small{01XXX - Metodi e strumenti di coprogettazione di sistemi digitali }
\end{center}

\section{Specifiche di progetto}
Realizzare un odometro rotativo assoluto, da connettere ad un encoder
incrementale con ingresso di 0 (A, B, Z: segnali TTL). Deve misurare l'angolo
(bidirezionale) e il numero di giri, acquisibili via RS232, e fornire un
impulso su un'uscita TTL ogni K gradi (programmabile), solo quando l'angolo
sia compreso fra K1 e K2 gradi (entrambi programmabili). Deve essere
programmabile (via RS232) per impostare il coefficiente angolare dell'encoder
(gradi per impulso) e le costanti K, K1 e K2. Risoluzione 0.1 grado, angolo
massimo 1000 giri. Alimentazione 5VDC+/-5\%.

\section{Analisi dei casi d'uso}
\begin{center}
    \includegraphics[width=14cm]{uml/odometer_usecases.pdf}
    \label{usecases}
\end{center}

Gli attori rappresentano le due sorgenti di input dell'Odometro,
ovvero l'interfaccia seriale \textbf{RS232} e l'output
dell'\textbf{Encoder} incrementale.

\begin{description}
\item[Invio via seriale:] \textbf{RS232} invia all'Odometro dei dati tramite l'interfaccia
     seriale di quest'ultimo.
\item[Invio comando:] I dati inviati da \textbf{RS232} all'interfaccia seriale dell'Odometro
     rappresentano un comando che deve essere decodificato.
\item[Invio dati:] A seguito di un comando che richiede dati aggiuntivi per essere
     eseguito, \textbf{RS232} provvede a fornire i dati necessari all'Odometro.
\item[Ricezione via seriale:] A seguito di un comando di lettura, \textbf{RS232} attende di
     ricevere i dati richiesti all'Odometro.
\item[Lettura angolo:] Il comando inviato all'Odometro richiede la lettura del
     valore corrente dell'angolo e questo viene ricevuto tramite l'interfaccia
     seriale.
\item[Lettura rivoluzioni:] Il comando inviato all'Odometro richiede la lettura del
     valore corrente del contatore delle rivoluzioni e questo viene ricevuto
     tramite l'interfaccia seriale.
\item[Imposta coefficiente:] Il comando inviato all'Odometro richiede l'impostazione
     del coefficiente angolare corrispondente a un segnale dell'Encoder e il valore
     viene trasmesso attraverso l'interfaccia seriale.
\item[Imposta K:] Il comando inviato all'Odometro richiede l'impostazione del
     parametro K e il valore viene trasmesso attraverso l'interfaccia seriale.
\item[Imposta K1:] Il comando inviato all'Odometro richiede l'impostazione del
     parametro K1 e il valore viene trasmesso attraverso l'interfaccia seriale.
\item[Imposta K2:] Il comando inviato all'Odometro richiede l'impostazione del
     parametro K2 e il valore viene trasmesso attraverso l'interfaccia seriale.

\item[Ruota di K gradi:] \textbf{Encoder} segnala all'Odometro una rotazione di
     K gradi in direzione oraria o antioraria secondo la codifica dei segnali A e B.
\item[Compie giro completo:] \textbf{Encoder} segnala all'Odometro il passaggio del
     marcatore di giro completo Z.
\item[Decodifica rotazione:] A seguito delle segnalazioni ricevute
     dall'\textbf{Encoder}, Odometro ne effettua la decodifica per determinarne
     il senso di rotazione.
\item[Aggiorna contatori:] Dopo la decodifica della direzione, i contatori di
     angolo e rivoluzioni vengono aggiornati tenendo conto dello stato corrente
     e delle segnalazioni ricevute.
\item[Segnala output:] Se l'angolo corrente soddisfa i criteri impostati con K, 
     K1 e K2 il segnale di output viene alzato per un colpo di clock.
\end{description}


\section{Analisi delle classi}
\begin{center}
    \includegraphics[width=14cm]{uml/odometer_classes.pdf}
    \label{usecases}
\end{center}

\subsection{Odometer}
La classe \textbf{Odometer} è la classe principale del sistema e
impiega al suo interno gli altri componenti.

Lo stato della classe \textbf{Odometer} è rappresentato
dai seguenti attributi:

\begin{description}
\item[int angle:] l'angolo derminato dalla posizione corrente dell'encoder,
     in decimi di grado
\item[int revolutions:] il numero di rivoluzioni compiute finora dall'encoder
\item[int K:] il numero di gradi per i quali il sistema deve emettere un
     impulso in uscita, in decimi di grado
\item[int K1:] il limite inferiore dell'intervallo all'interno del quale
     il sistema emette impulsi, in decimi di grado
\item[int K2:] il limite superiore dell'intervallo all'interno del quale
     il sistema emette impulsi, in decimi di grado
\item[int coeff:] il numero di gradi a cui corrisponde un settore
     dell'encoder in ingresso
\end{description}

I metodi che agiscono sull'oggetto \textbf{Odometer} sono i seguenti:

\begin{description}
\item[void setCoeff(value: int):] imposta il campo \textbf{coeff} al
     valore specificato
\item[void setK(value: int):] imposta il campo \textbf{K} al
     valore specificato
\item[void setK1(value: int):] imposta il campo \textbf{K1} al
     valore specificato
\item[void setK2(value: int):] imposta il campo \textbf{K2} al
     valore specificato
\item[void rotationClockWise():] segnala un movimento in senso orario
     dell'encoder
\item[void rotationCounterClockWise():] segnala un movimento in senso 
     antiorario dell'encoder
\item[void revolution():] segnala una rivoluzione completa dell'encoder
\item[int getAngle():] richiede il valore del campo \textbf{angle}
\item[int getRevolutions():] richiede il valore del campo
    \textbf{revolutions}
\item[void reset():] reimposta lo stato dell'oggetto
\end{description}

\subsection{EncoderInterface}
L'oggetto \textbf{EncoderInterface} si occupa di ricevere i segnali
dall'encoder incrementale, di interpretarli e quindi di chiamare i
metodi \texttt{rotationClockWise}, \texttt{rotationCounterClockWise}
e \texttt{revolution} dell'oggetto \textbf{Odometer}.

\begin{description}
\item[void A(value: boolean):] notifica il cambiamento del segnale \texttt{A}
    dell'encoder
\item[void B(value: boolean):] notifica il cambiamento del segnale \texttt{B}
    dell'encoder
\item[void Z(value: boolean):] notifica il cambiamento del segnale \texttt{Z}
    dell'encoder
\item[void reset():] reimposta lo stato dell'oggetto
\end{description}

\subsection{OutputInterface}
\textbf{OutputInterface} provvede a fornire l'uscita TTL descritta nelle
specifiche.

\begin{description}
\item[void tick():] emette un impulso sull'uscita TTL per un periodo di clock
\item[void reset():] reimposta lo stato dell'oggetto
\end{description}

\subsection{Uart}
L'oggetto \textbf{Uart} trasmette e riceve dati attraverso l'interfaccia RS232,
convertendo i segnali in arrivo in un flusso di byte e, viceversa, convertendo
i dati in uscita nei segnali opportuni.

\begin{description}
\item[byte byteRx:] il byte ricevuto non ancora letto
\item[byte byteTx:] il byte da trasmettere
\item[boolean txBusy:] indica se l'\textbf{Uart} sta trasmettendo
\item[boolean rxAv:] indica se è presente un byte non ancora letto
\end{description}

I metodi disponibili per l'oggetto \textbf{Uart} sono i seguenti:

\begin{description}
\item[void readRxData():] notifica l'\textbf{Uart} che il byte ricevuto è
    stato letto
\item[void loadTxData():] notifica l'\textbf{Uart} che è stato caricato il
    byte da trasmettere
\item[void reset():] reimposta lo stato dell'oggetto
\end{description}

\subsection{SerialController}
Il \textbf{SerialController} si occupa di gestire l'\textbf{Uart}
rendendone accessibili le funzionalità al resto del sistema,
attraverso interfacce standard come interrupt e bus di sistema.

\begin{description}
\item[void txBusy(value: boolean):] notifica che lo stato di trasmissione
    dell'\textbf{Uart} è cambiato
\item[void rxAv(value: boolean):] notifica che la disponibilità di dati
    in ingresso dall'\textbf{Uart} è cambiata
\item[byte getStatus():] restituisce lo stato dell'\textbf{Uart},con il
    bit 0 che indica la disponibilità di dati in ingresso e il bit 1 che
    indica se l'\textbf{Uart} è occupato nella trasmissione di un dato
\item[byte getData():] restituisce i dati in ingresso
\item[void setData(value: byte):] imposta i dati in uscita
\item[void reset():] reimposta lo stato dell'oggetto
\end{description}

\subsection{SerialInterface}
\textbf{SerialInterface} si occupa di ricevere dati attraverso il
\textbf{SerialController} e di interpretarli come comandi per
l'\textbf{Odometer} chiamandone i metodi, nonché di occuparsi
dell'invio delle risposte verso il \textbf{SerialController}.

\begin{description}
\item[void serialNotify():] notifica \textbf{SerialInterface} che
    lo stato del \textbf{SerialController} è cambiato
\item[void send(value: int):] invia i dati verso il
    \textbf{SerialController}
\item[void reset():] reimposta lo stato dell'oggetto
\end{description}

\section{Implementazione}

Le classi \textbf{Odometer} e \textbf{SerialInterface} sono state
realizzate in software, mentre \textbf{EncoderInterface}, 
\textbf{OutputInterface}, \textbf{Uart}, \textbf{SerialController}
sono state realizzate in hardware.

\subsection{Mappa di memoria}
\begin{tabular}{|l|l|l|l|}
\hline
Indirizzo & Componente & Lettura & Scrittura \\
\hline
\texttt{0x0000} & IRQ Controller & IRQ attivi & IRQ gestiti \\
\hline
\texttt{0x0001} & SerialController & Dati ricevuti & Data da trasmettere \\
\hline
\texttt{0x0002} & SerialController & Stato corrente & \\
\hline
\texttt{0x0003} & OutputInterface & & Impulso in uscita \\
\hline
\end{tabular}

\lstinputlisting[language=C]{software/memory_map.h}

\subsection{Odometer}
\subsubsection{software/odometer.h}
\lstinputlisting[language=C]{software/odometer.h}
\subsubsection{software/odometer.c}
\lstinputlisting[language=C]{software/odometer.c}

\subsection{SerialInterface}
\subsubsection{software/serial\_interface.h}
\lstinputlisting[language=C]{software/serial_interface.h}
\subsubsection{software/serial\_interface.c}
\lstinputlisting[language=C]{software/serial_interface.c}

\subsection{EncoderInterface}
\subsubsection{hardware/encoder\_interface.vhdl}
\lstinputlisting[language=VHDL]{hardware/encoder_interface.vhdl}

\subsection{OutputInterface}
\subsubsection{hardware/output\_interface.vhdl}
\lstinputlisting[language=VHDL]{hardware/encoder_interface.vhdl}

\subsection{Uart}
\subsubsection{hardware/uart.vhdl}
\lstinputlisting[language=VHDL]{hardware/uart.vhdl}

\subsection{SerialController}
\subsubsection{hardware/serial\_controller.vhdl}
\lstinputlisting[language=VHDL]{hardware/serial_controller.vhdl}

\subsection{Interfaccia software/hardware}
Per la simulazione della parte hardware si è usato GHDL, mentre quella software
è stata compilata con GCC. L'interfaccia hardware/software è stata quindi emulata
facendo comunicare le due sezioni attraverso i rispettivi standard input e output,
implementando anche un controller di interrupt nella parte hardware.

\subsection{software/software.c}
\lstinputlisting[language=C]{software/software.c}

\subsection{hardware/hardware.vhdl}
\lstinputlisting[language=VHDL]{hardware/hardware.vhdl}

\subsubsection{software/swhw\_interface.h}
\lstinputlisting[language=C]{software/swhw_interface.h}

\subsubsection{software/swhw\_interface.c}
\lstinputlisting[language=C]{software/swhw_interface.c}

\subsubsection{hardware/hwsw\_interface.vhdl}
\lstinputlisting[language=VHDL]{hardware/hwsw_interface.vhdl}

\subsubsection{hardware/interrupt\_controller.vhdl}
\lstinputlisting[language=VHDL]{hardware/interrupt_controller.vhdl}


\section{Ulteriori informazioni}
L'intero progetto è disponibile presso \link{http://techn.ocracy.org/odometer}, da cui
è inoltre possibile visionare tutte le revisioni realizzate durante lo sviluppo.
Il repository contiene inoltre i sorgenti di questo documento e il Makefile
per GNU~make usato per automatizzare il processo di compilazione e test.

\end{document}
