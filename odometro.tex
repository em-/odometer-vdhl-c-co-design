\documentclass [11pt,a4paper,oneside]{paper}

\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{verbatim}
\usepackage{color}
\usepackage{listings}
\usepackage{latexsym}

% Informations
\title{Odometro rotativo assoluto}
\author{Emanuele Aina (matr. 129548)}
\date{}

% Margins
\geometry{bindingoffset=0.5cm}

% Links
\definecolor{links}{rgb}{0.7,0.2,0}
\usepackage{ifpdf}
\ifpdf
    \usepackage{hyperref}
    \hypersetup{colorlinks=true,bookmarks=true,hypertexnames=false,urlcolor=links}
\else
    \newcommand{\href}[2]{#2}
\fi
\newcommand{\link}[1]{\href{#1}{#1}}

% Ignore the argument
\newcommand{\noop}[1]{}

\newcommand{\actor}[1]{\textbf{#1}}
\newcommand{\component}[1]{\textbf{#1}}
\newcommand{\identifier}[1]{\texttt{#1}}

% Justify even if it has to leave a lot of blank space
\setlength{\emergencystretch}{3em}

\definecolor{comment}{rgb}{0,0,0.8}
\definecolor{keyword}{rgb}{0.9,0.5,0}
\definecolor{string}{rgb}{0.95,0,0}

\lstset{
    basicstyle=\ttfamily,
    % this sets the letter spacing as it is with the verbatim package
    basewidth=0.5em,
    keywordstyle=\color{keyword},
    commentstyle=\color{comment},
    stringstyle=\color{string},
    showstringspaces=false,
}


\begin{document}

\maketitle

\small{01GQPCY - Metodi e strumenti di coprogettazione di sistemi digitali }

\vskip 1.5cm

\section{Specifiche di progetto}
Realizzare un odometro rotativo assoluto, da connettere ad un encoder
incrementale con ingresso di 0 (A, B, Z: segnali TTL). Deve misurare l'angolo
(bidirezionale) e il numero di giri, acquisibili via RS232, e fornire un
impulso su un'uscita TTL ogni K gradi (programmabile), solo quando l'angolo
sia compreso fra K1 e K2 gradi (entrambi programmabili). Deve essere
programmabile (via RS232) per impostare il coefficiente angolare dell'encoder
(gradi per impulso) e le costanti K, K1 e K2. Risoluzione 0.1 grado, angolo
massimo 1000 giri. Alimentazione 5VDC+/-5\%.

\section{Analisi dei casi d'uso}
Gli attori rappresentano le due sorgenti di input dell'odometro,
ovvero l'interfaccia seriale \component{RS232} e l'output
dell'\component{Encoder} incrementale.

\begin{center}
    \includegraphics[width=14cm]{uml/odometer_encoder_usecase.pdf}
    \label{encoder_usecase}
\end{center}

\begin{description}
\item[Ruota di K gradi:] \actor{Encoder} segnala all'odometro una rotazione di
     K gradi in direzione oraria o antioraria secondo la codifica dei segnali A e B.
\item[Compie giro completo:] \actor{Encoder} segnala all'odometro il passaggio del
     marcatore di giro completo Z.
\item[Decodifica rotazione:] A seguito delle segnalazioni ricevute
     dall'\actor{Encoder}, odometro ne effettua la decodifica per determinarne
     il senso di rotazione.
\item[Aggiorna contatori:] Dopo la decodifica della direzione, i contatori di
     angolo e rivoluzioni vengono aggiornati tenendo conto dello stato corrente
     e delle segnalazioni ricevute.
\item[Segnala output:] Se l'angolo corrente soddisfa i criteri impostati con K, 
     K1 e K2 il segnale di output viene alzato per un colpo di clock.
\end{description}

\begin{center}
    \includegraphics[width=14cm]{uml/odometer_rs232_usecase.pdf}
    \label{rs232_usecase}
\end{center}

\begin{description}
\item[Invio via seriale:] \actor{RS232} invia all'odometro dei dati tramite l'interfaccia
     seriale di quest'ultimo.
\item[Invio comando:] I dati inviati da \actor{RS232} all'interfaccia seriale dell'odometro
     rappresentano un comando che deve essere decodificato.
\item[Invio dati:] A seguito di un comando che richiede dati aggiuntivi per essere
     eseguito, \actor{RS232} provvede a fornire i dati necessari all'odometro.
\item[Ricezione via seriale:] A seguito di un comando di lettura, \actor{RS232} attende di
     ricevere i dati richiesti all'odometro.
\item[Lettura angolo:] Il comando inviato all'odometro richiede la lettura del
     valore corrente dell'angolo e questo viene ricevuto tramite l'interfaccia
     seriale.
\item[Lettura rivoluzioni:] Il comando inviato all'odometro richiede la lettura del
     valore corrente del contatore delle rivoluzioni e questo viene ricevuto
     tramite l'interfaccia seriale.
\item[Imposta coefficiente:] Il comando inviato all'odometro richiede l'impostazione
     del coefficiente angolare corrispondente a un segnale dell'Encoder e il valore
     viene trasmesso attraverso l'interfaccia seriale.
\item[Imposta K:] Il comando inviato all'odometro richiede l'impostazione del
     parametro K e il valore viene trasmesso attraverso l'interfaccia seriale.
\item[Imposta K1:] Il comando inviato all'odometro richiede l'impostazione del
     parametro K1 e il valore viene trasmesso attraverso l'interfaccia seriale.
\item[Imposta K2:] Il comando inviato all'odometro richiede l'impostazione del
     parametro K2 e il valore viene trasmesso attraverso l'interfaccia seriale.
\end{description}


\section{Analisi delle classi}
\begin{center}
    \includegraphics[width=14cm]{uml/odometer_classes.pdf}
    \label{usecases}
\end{center}

\subsection{Odometer}
La classe \component{Odometer} è la classe principale del sistema e
impiega al suo interno gli altri componenti.

Lo stato della classe \component{Odometer} è rappresentato
dai seguenti attributi:

\begin{description}
\item[int angle:] l'angolo derminato dalla posizione corrente dell'encoder,
     in decimi di grado
\item[int revolutions:] il numero di rivoluzioni compiute finora dall'encoder
\item[int K:] il numero di gradi per i quali il sistema deve emettere un
     impulso in uscita, in decimi di grado
\item[int K1:] il limite inferiore dell'intervallo all'interno del quale
     il sistema emette impulsi, in decimi di grado
\item[int K2:] il limite superiore dell'intervallo all'interno del quale
     il sistema emette impulsi, in decimi di grado
\item[int coeff:] il numero di gradi a cui corrisponde un settore
     dell'encoder in ingresso
\end{description}

I metodi che agiscono sull'oggetto \component{Odometer} sono i seguenti:

\begin{description}
\item[void setCoeff(value: int):] imposta il campo \identifier{coeff} al
     valore specificato
\item[void setK(value: int):] imposta il campo \identifier{K} al
     valore specificato
\item[void setK1(value: int):] imposta il campo \identifier{K1} al
     valore specificato
\item[void setK2(value: int):] imposta il campo \identifier{K2} al
     valore specificato
\item[void rotationClockWise():] segnala un movimento in senso orario
     dell'encoder
\item[void rotationCounterClockWise():] segnala un movimento in senso 
     antiorario dell'encoder
\item[void revolution():] segnala una rivoluzione completa dell'encoder
\item[int getAngle():] richiede il valore del campo \identifier{angle}
\item[int getRevolutions():] richiede il valore del campo
    \identifier{revolutions}
\item[void reset():] reimposta lo stato dell'oggetto
\end{description}

\subsection{EncoderInterface}
L'oggetto \component{EncoderInterface} si occupa di ricevere i segnali
dall'encoder incrementale, di interpretarli e quindi di chiamare i
metodi \identifier{rotationClockWise}, \identifier{rotationCounterClockWise}
e \identifier{revolution} dell'oggetto \component{Odometer}.

\begin{description}
\item[void A(value: boolean):] notifica il cambiamento del segnale \identifier{A}
    dell'encoder
\item[void B(value: boolean):] notifica il cambiamento del segnale \identifier{B}
    dell'encoder
\item[void Z(value: boolean):] notifica il cambiamento del segnale \identifier{Z}
    dell'encoder
\item[void reset():] reimposta lo stato dell'oggetto
\end{description}

\subsection{OutputInterface}
\component{OutputInterface} provvede a fornire l'uscita TTL descritta nelle
specifiche.

\begin{description}
\item[void tick():] emette un impulso sull'uscita TTL per un periodo di clock
\item[void reset():] reimposta lo stato dell'oggetto
\end{description}

\subsection{Uart}
L'oggetto \component{Uart} trasmette e riceve dati attraverso l'interfaccia RS232,
convertendo i segnali in arrivo in un flusso di byte e, viceversa, convertendo
i dati in uscita nei segnali opportuni.

\begin{description}
\item[byte byteRx:] il byte ricevuto non ancora letto
\item[byte byteTx:] il byte da trasmettere
\item[boolean txBusy:] indica se l'\component{Uart} sta trasmettendo
\item[boolean rxAv:] indica se è presente un byte non ancora letto
\end{description}

I metodi disponibili per l'oggetto \component{Uart} sono i seguenti:

\begin{description}
\item[void readRxData():] notifica l'\component{Uart} che il byte ricevuto è
    stato letto
\item[void loadTxData():] notifica l'\component{Uart} che è stato caricato il
    byte da trasmettere
\item[void reset():] reimposta lo stato dell'oggetto
\end{description}

\subsection{SerialController}
Il \component{SerialController} si occupa di gestire l'\component{Uart}
rendendone accessibili le funzionalità al resto del sistema,
attraverso interfacce standard come interrupt e bus di sistema.

\begin{description}
\item[void txBusy(value: boolean):] notifica che lo stato di trasmissione
    dell'\component{Uart} è cambiato
\item[void rxAv(value: boolean):] notifica che la disponibilità di dati
    in ingresso dall'\component{Uart} è cambiata
\item[byte getStatus():] restituisce lo stato dell'\component{Uart},con il
    bit 0 che indica la disponibilità di dati in ingresso e il bit 1 che
    indica se l'\component{Uart} è occupato nella trasmissione di un dato
\item[byte getData():] restituisce i dati in ingresso
\item[void setData(value: byte):] imposta i dati in uscita
\item[void reset():] reimposta lo stato dell'oggetto
\end{description}

\subsection{SerialInterface}
\component{SerialInterface} si occupa di ricevere dati attraverso il
\component{SerialController} e di interpretarli come comandi per
l'\component{Odometer} chiamandone i metodi, nonché di occuparsi
dell'invio delle risposte verso il \component{SerialController}.

\begin{description}
\item[void serialNotify():] notifica \component{SerialInterface} che
    lo stato del \component{SerialController} è cambiato
\item[void send(value: int):] invia i dati verso il
    \component{SerialController}
\item[void reset():] reimposta lo stato dell'oggetto
\end{description}

\section{Implementazione}

Le classi \component{Odometer} e \component{SerialInterface} sono state
realizzate in software, mentre \component{EncoderInterface}, 
\component{OutputInterface}, \component{Uart}, \component{SerialController}
sono state realizzate in hardware.

\subsection{Mappa di memoria}
\begin{tabular}{|l|l|l|l|}
\hline
Indirizzo & Componente & Lettura & Scrittura \\
\hline
\texttt{0x1000} & IRQ Controller & IRQ attivi & IRQ gestiti \\
\hline
\texttt{0x1001} & SerialController & Dati ricevuti & Dati da trasmettere \\
\hline
\texttt{0x1002} & SerialController & Stato corrente & \\
\hline
\texttt{0x1003} & OutputInterface & & Impulso in uscita \\
\hline
\end{tabular}

\lstinputlisting[language=C]{software/memory_map.h}

\subsection{Richieste di interrupt}
\begin{tabular}{|l|l|l|}
\hline
Linea & Componente & Segnale \\
\hline
\texttt{0} & EncoderInterface & Rotazione in senso antiorario \\
\hline
\texttt{1} & EncoderInterface & Rotazione in senso orario \\
\hline
\texttt{2} & EncoderInterface & Rivoluzione completa \\
\hline
\texttt{3} & SerialController & Cambiamento di stato \\
\hline
\end{tabular}

\subsection{Odometer}
\subsubsection{software/odometer.h}
\lstinputlisting[language=C]{software/odometer.h}
\subsubsection{software/odometer.c}
\lstinputlisting[language=C]{software/odometer.c}

\subsection{SerialInterface}
\subsubsection{software/serial\_interface.h}
\lstinputlisting[language=C]{software/serial_interface.h}
\subsubsection{software/serial\_interface.c}
\lstinputlisting[language=C]{software/serial_interface.c}

\subsection{EncoderInterface}
\subsubsection{hardware/encoder\_interface.vhdl}
\lstinputlisting[language=VHDL]{hardware/encoder_interface.vhdl}

\subsection{OutputInterface}
\subsubsection{hardware/output\_interface.vhdl}
\lstinputlisting[language=VHDL]{hardware/encoder_interface.vhdl}

\subsection{Uart}
\subsubsection{hardware/uart.vhdl}
\lstinputlisting[language=VHDL]{hardware/uart.vhdl}

\subsection{SerialController}
\subsubsection{hardware/serial\_controller.vhdl}
\lstinputlisting[language=VHDL]{hardware/serial_controller.vhdl}

\subsection{Interfaccia software/hardware}
Per la simulazione della parte hardware si è usato GHDL, mentre quella software
è stata compilata con GCC. L'interfaccia hardware/software è stata quindi emulata
facendo comunicare le due sezioni attraverso i rispettivi standard input e output,
implementando anche un controller di interrupt nella parte hardware.

\subsubsection{software/software.c}
\lstinputlisting[language=C]{software/software.c}

\subsubsection{hardware/hardware.vhdl}
\lstinputlisting[language=VHDL]{hardware/hardware.vhdl}

\subsubsection{software/swhw\_interface.h}
\lstinputlisting[language=C]{software/swhw_interface.h}

\subsubsection{software/swhw\_interface.c}
\lstinputlisting[language=C]{software/swhw_interface.c}

\subsubsection{hardware/hwsw\_interface.vhdl}
\lstinputlisting[language=VHDL]{hardware/hwsw_interface.vhdl}

\subsubsection{hardware/interrupt\_controller.vhdl}
\lstinputlisting[language=VHDL]{hardware/interrupt_controller.vhdl}


\section{Ulteriori informazioni}
L'intero progetto è disponibile presso \link{http://techn.ocracy.org/odometer}, da cui
è inoltre possibile visionare tutte le revisioni realizzate durante lo sviluppo.
Il repository contiene inoltre i sorgenti di questo documento e il Makefile
per GNU~Make usato per automatizzare il processo di compilazione e test.

Per la simulazione è necessario installare, oltre a GNU~Make e GCC, Python
(usato per lanciare la simulazione stessa) e GHDL, e in seguito eseguire
\texttt{make run}. Per generare la documentazione sono necessari \LaTeX,
Rubber, UMLSpeed e Inkscape.

\end{document}
